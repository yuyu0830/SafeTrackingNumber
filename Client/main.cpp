#define _WINSOCK_DEPRECATED_NO_WARNINGS // winsock c4996 처리

#include <iostream>
#include <stdint.h>
#include <winsock2.h>
#include <WS2tcpip.h>
#include <string>
#include <thread>

#include "Crypto/kem.h"
#include "Crypto/indcpa.h"

#define PACKET_SIZE 1024
#define SERVER_PORT 54000
#define SERVER_IP_ADDR "127.0.0.1"

#define SECRET_KEY_SIZE 384 * 2
#define PUBLIC_KEY_SIZE 384 * 2 + 32
#define KYBER_CIPHERTEXTBYTES 768

using namespace std;

#pragma comment(lib,"ws2_32.lib") // ws2_32.lib 라이브러리를 링크

WSADATA wsData;
SOCKET soc;

uint8_t UserSecretKey[384 * 2];
uint8_t DeliverySecretKey[384 * 2];

const uint8_t DeliverySecretKey2[SECRET_KEY_SIZE] = { 0xa7, 0x15, 0x28, 0x61, 0xea, 0x33, 0x73, 0x3b, 0x29, 0x0b, 0x4b, 0x0b, 0xae, 0xa2, 0x37, 0xb1, \
0x79, 0x27, 0xf0, 0x10, 0xc8, 0xcc, 0x43, 0x9a, 0x91, 0xfc, 0x93, 0xfd, 0xa1, 0x2f, 0x86, 0xb4,							   \
0x34, 0x0b, 0xb3, 0xb4, 0xa6, 0x57, 0xbf, 0x57, 0x8b, 0x25, 0xa8, 0x3c, 0xae, 0xa2, 0x19, 0x4d,							   \
0x2b, 0xca, 0xb5, 0x82, 0x68, 0x3e, 0x2c, 0x1b, 0x50, 0x1b, 0x39, 0x18, 0x77, 0xa2, 0x90, 0xef,							   \
0x28, 0x3a, 0x9a, 0x35, 0x92, 0x09, 0x76, 0x6e, 0xc4, 0x94, 0x8b, 0x53, 0x78, 0xc0, 0x00, 0x98,							   \
0xcd, 0x36, 0x74, 0x14, 0x0c, 0x31, 0x37, 0x95, 0x00, 0x66, 0x9a, 0x02, 0x1d, 0xc4, 0x37, 0x93,							   \
0xcf, 0xe6, 0x07, 0xeb, 0x52, 0xa5, 0x0d, 0x73, 0x8e, 0x5c, 0xcb, 0x35, 0x5c, 0x2b, 0x37, 0xed,							   \
0xb0, 0xac, 0x31, 0xaa, 0xa1, 0x15, 0x91, 0x7b, 0x7f, 0x65, 0x97, 0xae, 0x23, 0x6f, 0x1e, 0x34,							   \
0x70, 0x7a, 0xaa, 0x1b, 0xfa, 0xf2, 0xbd, 0xd0, 0x6a, 0x6b, 0x57, 0x73, 0xc9, 0x6b, 0x9c, 0x25,							   \
0x38, 0x85, 0x81, 0xb4, 0x1a, 0x50, 0x81, 0xb5, 0x0e, 0x4a, 0x38, 0x59, 0x21, 0xa1, 0x57, 0x7e,							   \
0xe5, 0x66, 0x5f, 0x43, 0x3a, 0x84, 0x76, 0x7c, 0x8e, 0xf0, 0x74, 0xe8, 0xcb, 0x91, 0x29, 0xd4,							   \
0xc0, 0xf1, 0xd0, 0x01, 0xf4, 0xd5, 0x19, 0x2f, 0xa2, 0x27, 0xe9, 0x3c, 0xcb, 0x78, 0x7c, 0x40,							   \
0x6e, 0x32, 0xb0, 0xa6, 0xf9, 0x79, 0xfb, 0x15, 0x1a, 0xc5, 0xf3, 0x4a, 0x0e, 0x11, 0x9f, 0xa4,							   \
0xe9, 0xbe, 0xbe, 0xd3, 0xb1, 0x20, 0x54, 0x7f, 0x3f, 0x82, 0x57, 0x51, 0xc2, 0x9b, 0xe4, 0xf3,							   \
0xc6, 0xff, 0x36, 0x37, 0x72, 0xc8, 0x4e, 0x18, 0x70, 0x58, 0xb4, 0x86, 0x07, 0x07, 0xb4, 0x44,							   \
0x29, 0x12, 0x06, 0xed, 0x50, 0x85, 0x00, 0xcc, 0x63, 0xb9, 0xcc, 0x43, 0x47, 0xc5, 0x0a, 0x3c,							   \
0x27, 0x33, 0x05, 0x97, 0xae, 0xbb, 0x72, 0x69, 0x1b, 0xf8, 0x74, 0x5e, 0xa6, 0xcf, 0x98, 0x58,							   \
0x9f, 0x18, 0x2c, 0xa1, 0xa8, 0xf6, 0x2c, 0x49, 0x14, 0x4d, 0x6f, 0xf2, 0x4c, 0xc8, 0x90, 0xcb,							   \
0x9f, 0xe5, 0xbe, 0xee, 0xea, 0x1a, 0x15, 0x6b, 0x30, 0x5a, 0xc9, 0x15, 0xbc, 0x7c, 0x1b, 0x37,							   \
0x3c, 0xbe, 0x9f, 0x27, 0xb5, 0x6c, 0xac, 0x64, 0x97, 0x1a, 0x4e, 0xad, 0x31, 0x44, 0xcd, 0x6b,							   \
0x4e, 0xb6, 0x23, 0xc5, 0x3b, 0x33, 0x53, 0xf1, 0x5b, 0x52, 0x0c, 0x52, 0x86, 0x9c, 0xf9, 0x50,							   \
0xe0, 0xe5, 0x63, 0xbd, 0x70, 0x3c, 0x3e, 0x68, 0x87, 0xba, 0x88, 0x1a, 0x6b, 0x4c, 0x01, 0x85,							   \
0x99, 0xb1, 0x31, 0x92, 0x07, 0x70, 0xdb, 0x6c, 0x58, 0x90, 0x4a, 0x99, 0xe6, 0x83, 0x78, 0x3c,							   \
0x3c, 0x66, 0xc9, 0x29, 0x03, 0xa6, 0x1e, 0x36, 0x2c, 0xc7, 0xe4, 0x37, 0xa8, 0x7b, 0x74, 0xcb,							   \
0xbf, 0x94, 0x38, 0x1b, 0x81, 0x12, 0xee, 0x91, 0x71, 0xb8, 0x79, 0xae, 0x1f, 0x61, 0x79, 0xcc,							   \
0x5a, 0xbc, 0xb0, 0x23, 0x98, 0xb4, 0xda, 0xbf, 0xfe, 0x34, 0xcf, 0x76, 0x67, 0xb8, 0x6d, 0xec,							   \
0x61, 0xcc, 0x10, 0x3e, 0xaf, 0xa6, 0xa3, 0x87, 0x84, 0x83, 0xac, 0x03, 0x57, 0x38, 0xc7, 0xca,							   \
0x8d, 0x2c, 0x1d, 0xcb, 0x4a, 0x71, 0x9a, 0x29, 0x1f, 0xb8, 0x85, 0x24, 0x1a, 0xdb, 0xa0, 0x7b,							   \
0x88, 0x12, 0x26, 0x31, 0x5d, 0x73, 0xd7, 0x8f, 0xd0, 0xc7, 0xca, 0x23, 0x7c, 0x61, 0x47, 0x9c,							   \
0x87, 0xff, 0xca, 0xc3, 0x28, 0x61, 0x2b, 0x67, 0x98, 0x1b, 0x9e, 0xd5, 0xbd, 0x93, 0x01, 0xa7,							   \
0x58, 0xf9, 0x12, 0x7a, 0xac, 0x2a, 0x79, 0xcb, 0x52, 0xea, 0xe4, 0x74, 0x73, 0x13, 0x07, 0xca,							   \
0x39, 0x5b, 0x14, 0xbb, 0x16, 0x39, 0xe4, 0x75, 0x73, 0xd2, 0x7b, 0x12, 0x51, 0xc8, 0x4b, 0xd8,							   \
0xaf, 0x7e, 0x7c, 0x1d, 0xe8, 0x7b, 0x0e, 0x7c, 0x88, 0x70, 0xba, 0x9b, 0x0a, 0x14, 0xc6, 0x48,							   \
0xd5, 0x19, 0x17, 0x68, 0x65, 0x07, 0x9f, 0x23, 0x4e, 0x1a, 0x72, 0x57, 0xc5, 0x90, 0xb2, 0x00,							   \
0x78, 0x67, 0xc0, 0xba, 0x41, 0x8f, 0x1c, 0x47, 0x59, 0x52, 0x20, 0x10, 0xba, 0xb5, 0x96, 0xd6,							   \
0x05, 0x0b, 0x86, 0x41, 0x29, 0x5b, 0x51, 0x38, 0x79, 0x55, 0xb6, 0x93, 0x50, 0x31, 0x28, 0x78,							   \
0x3c, 0x67, 0x17, 0xfb, 0x9a, 0x00, 0x97, 0x1c, 0x43, 0xa2, 0x72, 0x5d, 0x97, 0x00, 0x84, 0xe5,							   \
0xd2, 0x6c, 0xc3, 0x16, 0x4b, 0x0a, 0x16, 0x8b, 0x9b, 0x31, 0x09, 0x5e, 0x51, 0x65, 0x12, 0x66,							   \
0xa7, 0xce, 0xe4, 0x17, 0x38, 0xc0, 0x24, 0xfe, 0x87, 0xa1, 0x23, 0xf2, 0x40, 0x41, 0x88, 0xbf,							   \
0xb7, 0x91, 0x0c, 0x96, 0xd1, 0xbf, 0x7e, 0x9c, 0x5f, 0x30, 0xa5, 0x32, 0xc5, 0x75, 0x67, 0xb2,							   \
0x39, 0x65, 0x97, 0x0c, 0x54, 0x36, 0x5c, 0xaa, 0x2b, 0xe3, 0x8a, 0x78, 0x88, 0x13, 0x48, 0xf2,							   \
0x5c, 0x64, 0xb9, 0x97, 0xa0, 0x61, 0x3d, 0x73, 0xc2, 0xb9, 0x81, 0x47, 0x49, 0x2a, 0x46, 0x10,							   \
0x6e, 0x5b, 0x9e, 0xa3, 0x39, 0x57, 0xf6, 0xa5, 0x52, 0xa0, 0x01, 0x31, 0x7d, 0x1a, 0x62, 0x1d,							   \
0x3b, 0xa0, 0x4e, 0x70, 0xb6, 0x49, 0x71, 0xaf, 0x00, 0x44, 0x9b, 0x27, 0x7c, 0xab, 0x91, 0x4b,							   \
0xa8, 0x58, 0xab, 0xa7, 0x4a, 0x2b, 0x97, 0x30, 0x17, 0x7e, 0x02, 0x48, 0x36, 0x25, 0x75, 0xbf,							   \
0xcf, 0x17, 0x97, 0xc7, 0x48, 0x86, 0x62, 0x04, 0x1e, 0xcf, 0x3c, 0x85, 0xb8, 0x48, 0x62, 0xfd,							   \
0x79, 0x0a, 0x16, 0x0c, 0x49, 0xc5, 0x8c, 0xc5, 0x74, 0x6a, 0x30, 0x08, 0x27, 0xb4, 0xfe, 0x16,							   \
0x22, 0xfe, 0xa4, 0xba, 0x0e, 0x38, 0xa4, 0xda, 0xda, 0x65, 0x29, 0x15, 0xc1, 0xe2, 0xb0, 0x76							   \
};

int SocketSetting();
void Terminate();

void CharToHex(const char* source, char* destination, int length)
{
	for (int i = 0; i < length; i++) {
		char first = source[i * 2];
		char second = source[i * 2 + 1];

		first = first - (first >= 'A' ? 55 : 48);
		second = second - (second >= 'A' ? 55 : 48);

		destination[i] = (first << 4) + second;
	}
}

int main()
{
	if (SocketSetting()) {
		cout << "Can't Create Socket.." << endl;
		Terminate();
		return -1;
	}

	// Client 
	char msg[PACKET_SIZE] = { 0 };

	while (!WSAGetLastError()) {
		int input;
		cout << "input : ";
		cin >> input;
		if (input == 1) { // Create User
			ZeroMemory(msg, PACKET_SIZE);
			msg[0] = '1';
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Name : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Phone : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Addr : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			memcpy(UserSecretKey, msg, SECRET_KEY_SIZE);
		}

		else if (input == 2) { // Create Delivery Man
			ZeroMemory(msg, PACKET_SIZE);
			msg[0] = '2';
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Name : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Phone : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Addr : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			memcpy(DeliverySecretKey, msg, SECRET_KEY_SIZE);
		}

		else if (input == 3) { // Create Package
			ZeroMemory(msg, PACKET_SIZE);
			msg[0] = '3';
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "SendUserIdx : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			uint8_t m[32];

			indcpa_dec(m, (const uint8_t*)msg, UserSecretKey);
			send(soc, (const char*)m, 32, 0);

			for (int i = 0; i < 32; i++) {
				printf("%02x ", m[i]);
			}
			printf("\n");

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			if (msg[0] == 251) {
				cout << "Unverified!" << endl;
				break;
			}
			cout << "Verified! : " << msg << endl;

			ZeroMemory(msg, PACKET_SIZE);
			cout << "ReceiveUser : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "Package Name : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);
		}

		else if (input == 4) { // Take Package
			ZeroMemory(msg, PACKET_SIZE);
			msg[0] = '4';
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			cout << "DeliveryManIdx : ";
			cin >> msg;
			send(soc, msg, strlen(msg) + 1, 0);

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			uint8_t m[32];

			indcpa_dec(m, (const uint8_t*)msg, DeliverySecretKey);
			send(soc, (const char*)m, 32, 0);

			for (int i = 0; i < 32; i++) {
				printf("%02x ", m[i]);
			}
			printf("\n");

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			if (msg[0] == 251) {
				cout << "Unverified Delivery Man!" << endl;
				break;
			}
			cout << "Verified Delivery Man! : " << msg << endl;

			// Verify Package
			char buf[10000];
			cin >> buf;

			printf("\n");

			uint8_t ct[KYBER_CIPHERTEXTBYTES];
			CharToHex(buf, (char*) ct, KYBER_CIPHERTEXTBYTES);

			uint8_t mt[32];

			indcpa_dec(mt, ct, DeliverySecretKey2);

			send(soc, (const char*)mt, 32, 0);

			printf("\n");

			ZeroMemory(msg, PACKET_SIZE);
			recv(soc, msg, PACKET_SIZE, 0);

			if (msg[0] == 251) {
				cout << "Unverified Package!" << endl;
				break;
			}
			cout << "Complete!" << msg << endl;
		}
	}

	Terminate();

	return 0;
}



int SocketSetting() {
	if (WSAStartup(MAKEWORD(2, 2), &wsData)) {
		cerr << "Can't start Winsock.." << endl;
		return -1;
	}

	soc = socket(AF_INET, SOCK_STREAM, 0);

	if (soc == INVALID_SOCKET) {
		std::cerr << "Can't create socket, Err #" << WSAGetLastError() << std::endl;
		return -1;
	}

	SOCKADDR_IN hint{};
	hint.sin_family = AF_INET;
	hint.sin_port = htons(SERVER_PORT);
	hint.sin_addr.s_addr = inet_addr(SERVER_IP_ADDR);

	int connResult = connect(soc, (SOCKADDR*)&hint, sizeof(hint));

	for (int i = 0; i < 3; i++) {
		if (!connResult) break;
		else {
			cout << "Can't connect to server, Retry.. (" << i + 1 << "/3)" << endl;
			connResult = connect(soc, (SOCKADDR*)&hint, sizeof(hint));
		}
	}

	if (connResult == SOCKET_ERROR)
	{
		std::cerr << "Can't connect to server, Err #" << WSAGetLastError() << std::endl;
		Terminate();
		return -1;
	}

	return 0;
}


void Terminate() {
	closesocket(soc);
	WSACleanup();
}